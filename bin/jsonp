#! /usr/bin/env perl

use 5.014;
use autodie qw< :all >;
use warnings FATAL => 'all';
use experimental 'smartmatch';

use JSON;
use Perl6::Slurp;
use Method::Signatures;
use Getopt::Long::Descriptive;

$| = 1;


my ($opts, $usage) = describe_options(
	"%c %o '<perl program>'",
	[ 'loop=s' => "don't loop over input lines; loop over this composite key instead" ],
	[ 'help|h' => "this help message" ],
	[],
	[ q{your program is run in an implicit loop (like `perl -p`)} ],
	[ q{the default loop is per line-of-input, but you can change that with --loop} ],
	[ q{$j is set to the incoming JSON; by default, $_ is set to {}} ],
	[ q{you can copy all of $j to $_ with clone() (ex: 'clone() if $j->{foo} eq "fred"')} ],
	[ q{or copy only certain keys with copy() (ex: 'copy(qw< bar baz >) if $j->{foo} eq "fred"')} ],
	[ q{if %$_ is non-empty at the end of the loop, it is converted back to JSON and printed} ],
	[ q{or use `say` to print out whatever you like (ex: 'say $j->{bar} if $j->{foo} eq "fred"')} ],
	[ q{the p() fuction returns a key from $j (ex: 'say p("bar") if p("foo") eq "fred"': same as above)} ],
	[ q{a key to p() can be a "composite key": use "." to separate the levels} ],
	[ q{  so these programs are equivalent: 'say $j->{foo}->{bar}->[0]->{baz}' and 'say p("foo.bar.0.baz")'} ],
	[ q{composite keys can contain "*", meaning all values (ex: 'say $_->{baz} foreach p("foo.*.bar")')} ],
	[ q{can also use composite keys with --loop (ex: jsonp --loop "foo.*.bar" 'say p("baz")': same as above)} ],
	[ q{tsv() prints a tab-separated list of the supplied composite keys} ],
	[ q{  so these are equivalent: 'say join("\t", p(qw< foo bar >))' and 'tsv(qw< foo bar >)'} ],
	[ q{csv() is just like tsv(), but outputs comma-separated values (double-quoted)} ],
	[ q{use count() if you just want to gather counts of different values} ],
	[ q{  so these are similar: jsonp 'count(p("bar")) if p("foo") eq "fred"')} ],
	[ q{    and this: jsonp 'say p("bar") if p("foo") eq "fred"' | sort | uniq -c} ],
);
print $usage->text and exit if $opts->help;

my $prog = shift or die("usage: $0 'perl program to process json lines' [file ...]");
our $j;
our %count_results;

my $processor = q{
	sub process
	{
		local $_ = {};
		no warnings 'exiting';
		##prog##;
		say to_json($_) if %$_;
	}
	1;
};
$processor =~ s/##prog##/$prog/;
eval $processor or die("$0: compile error: $@");

if ($opts->loop)
{
	$j = from_json(scalar slurp);
	foreach (p($opts->loop))
	{
		local $j = $_;
		process();
	}
}
else
{
	while ( <> )
	{
		s/^.*?{/{/;
		unless ( eval { $j = from_json($_) } )
		{
			die("couldn't find valid json string in input") if eof();
			$_ .= <>;
			redo;
		}
		process();
	}
}

if (%count_results)
{
	say "$_ : $count_results{$_}" foreach sort keys %count_results;
}


func p ($composite_key = $_)
{
	my $cur = $j;
	my @keys = split(/\./, $composite_key);
	while (@keys)
	{
		my $key = shift @keys;
		if ($key eq '*')
		{
			my @values;
			$composite_key = join('.', @keys);
			given (ref $cur)
			{
				@values = @$cur							when 'ARRAY';
				@values = values %$cur					when 'HASH';
				die("can't deref a scalar ($cur.*)");	# otherwise
			}
			my @subs;
			foreach (@values)
			{
				local $j = $_;
				push @subs, p($composite_key);
			}
			return wantarray ? @subs : \@subs;
		}

		given (ref $cur)
		{
			when ('HASH')
			{
				exists $cur->{$key} or return '';						# could also warn here
				$cur = $cur->{$key};
			}
			when ('ARRAY')
			{
				$key =~ /^\d+$/ and $key <= $#$cur or return '';		# could also warn here
				$cur = $cur->[$key];
			}
			die("can't deref a scalar ($cur.$key)");
		}
	}

	if (wantarray)
	{
		given (ref $cur)
		{
			return @$cur				when 'ARRAY';
			return keys %$cur			when 'HASH';
			return $cur					when '';
		}
	}
	return $cur;
}

func copy (@keys)
{
	my $dest = $_;
	local $_;
	$dest->{$_} = p() foreach @keys;
}

func clone ()
{
	my $dest = $_;
	local $_;
	$dest->{$_} = $j->{$_} foreach keys %$j;
}

func csv (@keys)
{
	say join(',', map { s/"/\\"/g; qq{"$_"} } map { p() } @keys);
}

func tsv (@keys)
{
	say join("\t", map { p() } @keys);
}

func count ($value)
{
	++$count_results{$value};
}
