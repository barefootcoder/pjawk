#! /usr/bin/env perl

use 5.014;
use autodie qw< :all >;
use warnings FATAL => 'all';
use experimental 'smartmatch';

use JSON;
use Perl6::Slurp;
use Method::Signatures;
use List::Util qw< max >;
use Getopt::Long::Descriptive;

$| = 1;


my ($opts, $usage) = describe_options(
	"%c %o '<perl program>'",
	[ 'loop=s'    => "don't loop over input lines; loop over this composite key instead" ],
	[ 'extra|E=s' => "extract this extra info from the line and add it to the JSON" ],
	[ 'help|h'    => "this help message" ],
	[],
	[ q{your program is run in an implicit loop (like `perl -p`)} ],
	[ q{the default loop is per line-of-input, but you can change that with --loop} ],
	[ q{$j is set to the incoming JSON; by default, $_ is set to {}} ],
	[ q{you can copy all of $j to $_ with clone() (ex: 'clone() if $j->{foo} eq "fred"')} ],
	[ q{or copy only certain keys with copy() (ex: 'copy(qw< bar baz >) if $j->{foo} eq "fred"')} ],
	[ q{if %$_ is non-empty at the end of the loop, it is converted back to JSON and printed} ],
	[ q{or use `say` to print out whatever you like (ex: 'say $j->{bar} if $j->{foo} eq "fred"')} ],
	[ q{the path() fuction returns a key from $j (ex: 'say path("bar") if path("foo") eq "fred"': same as above)} ],
	[ q{  a colon followed by a keyname is a shortcut for path() (ex: 'say :bar if :foo eq "fred"': same as above)} ],
	[ q{  however, if you want to use the colon, your keyname can contain only letters, digits, and hyphens} ],
	[ q{a key to path() can be a "composite key": use "." to separate the levels} ],
	[ q{  so these programs are equivalent: 'say $j->{foo}->{bar}->[0]->{baz}' and 'say path("foo.bar.0.baz")'} ],
	[ q{  the colon operator works with composite keys too: 'say :foo.bar.0.baz' is the same as the above two} ],
	[ q{the path_exists() fuction takes a composite key and returns a boolen value if that key exists} ],
	[ q{  if any part of the composite key doesn't exist, path_exists() returns false} ],
	[ q{  a colon followed by a question mark then a keyname is a shortcut for this} ],
	[ q{  (ex: 'clone if :?foo.bar' same as 'clone if path_exists("foo.bar")')} ],
	[ q{  (both example are equivalent to 'clone if exists $j->{foo} and exists $j->{foo}->{bar}')} ],
	[ q{composite keys can contain "*", meaning all values (ex: 'say $_->{baz} foreach :foo.*.bar')} ],
	[ q{can also use composite keys with --loop (ex: jsonp --loop "foo.*.bar" 'say :baz': same as above)} ],
	[ q{tsv() prints a tab-separated list of the supplied values} ],
	[ q{  so these are equivalent: 'say join("\t", :foo, :bar)' and 'tsv(:foo, :bar)'} ],
	[ q{csv() is just like tsv(), but outputs comma-separated values (double-quoted)} ],
	[ q{use count() if you just want to gather counts of different values} ],
	[ q{  so this prog:           jsonp 'count(:bar) if :foo eq "fred"')} ],
	[ q{  is similar to this one: jsonp 'say :bar if :foo eq "fred"' | sort | uniq -c} ],
	[ q{  if something you count is undefined, it will be displayed as '<<undef>>'} ],
	[ q{  you can pass count() multiple values; it will count each possible combination of the values} ],
	[ q{use --extra (or -E) to extract extra fields from each line} ],
	[ q{  for instance, say each line had a datetime stamp, outside the JSON string} ],
	[ q{  you might need this datetime as part of your data, but it won't be in $j because it's outside the JSON} ],
	[ q{  so you might use: `--extra="timestamp => qr|\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}|"'} ],
	[ q{  the arg to -E is Perl code representing one or more key/value pairs:} ],
	[ q{    the key will be the name of the key inside $j (be careful not to overwrite an existing key)} ],
	[ q{    the value must be a regex; the value inside $j will be whatever that matches in the string (could be undef)} ],
	[ q{  multiple key/values are okay: `-E "date => qr|\d{4}/\d{2}/\d{2}|, ip => qr|(?:\d{1,3}\.){3}\d{1,3}|"'} ],
	[ q{  --extra is ignored with --loop} ],
);
print $usage->text and exit if $opts->help;

my $prog = shift or die("usage: $0 'perl program to process json lines' [file ...]");
$prog = fixup_prog($prog);

our $j;
our %count_results;

my $processor = q{
	sub process
	{
		local $_ = {};
		no warnings 'exiting';
		##prog##;
		say to_json($_) if %$_;
	}
	1;
};
$processor =~ s/##prog##/$prog/;
eval $processor or die("$0: compile error: $@");

my %read_extra = ();
if ($opts->extra)
{
	unless ( eval '%read_extra = (' . $opts->extra . ')' )
	{
		die("$0: compile error on extra fields: $@");
	}
}

if ($opts->loop)
{
	$j = from_json(scalar slurp);
	foreach (path($opts->loop))
	{
		local $j = $_;
		process();
	}
}
else
{
	while ( <> )
	{
		my %extra;
		if (%read_extra)
		{
			foreach my $e (keys %read_extra)
			{
				m{($read_extra{$e})};
				$extra{$e} = $1;
			}
		}

		s/^.*?{/{/;
		unless ( eval { $j = from_json($_) } )
		{
			die("couldn't find valid json string in input") if eof();
			$_ .= <>;
			redo;
		}
		$j->{$_} = $extra{$_} foreach keys %extra;						# no-op if %extra is empty
		process();
	}
}

if (%count_results)
{
	my $key_len = max map { length } keys %count_results;
	my $val_len = length max values %count_results;
	printf "%-${key_len}s : %${val_len}d\n", $_, $count_results{$_} foreach sort keys %count_results;
}


########
# SUBS #
########

func fixup_prog ($prog)
{
	use Text::Balanced qw< extract_quotelike extract_multiple >;
	state $KEY_RE = qr/[\w.*-]+/;

	# stash away quoted things so we don't get false positives
	# (as ever, stolen shamelessly from Filter::Simple by The Damian)
	my @quoted_strings;
	$prog = join('', map { ref $_ ? scalar((push @quoted_strings, $_), "{Q$#quoted_strings}") : $_ }
			extract_multiple($prog,
			[
					{ Q => sub { extract_quotelike($_[0]) } },
					qr/./,
			])
	);

	$prog =~ s/:($KEY_RE)/path(q{$1})/g;
	$prog =~ s/:\?($KEY_RE)/path_exists(q{$1})/g;

	$prog =~ s/{Q(\d+)}/${$quoted_strings[$1]}/g;						# put any quoted strings back
	return $prog;
}


func path			($composite_key = $_) { _find_path($composite_key, check_existence => 0) }
func path_exists	($composite_key = $_) { _find_path($composite_key, check_existence => 1) }

func _find_path ($composite_key, :$check_existence)
{
	my $cur = $j;
	my @keys = split(/\./, $composite_key);
	while (@keys)
	{
		my $key = shift @keys;
		if ($key eq '*')
		{
			my @values;
			$composite_key = join('.', @keys);
			given (ref $cur)
			{
				@values = @$cur							when 'ARRAY';
				@values = values %$cur					when 'HASH';
				die("can't deref a scalar ($cur.*)");	# otherwise
			}
			my @subs;
			foreach (@values)
			{
				local $j = $_;
				push @subs, path($composite_key);
			}
			return wantarray ? @subs : \@subs;
		}

		given (ref $cur)
		{
			when ('HASH')
			{
				exists $cur->{$key} or return undef;					# could also warn here, if not $check_existence
				$cur = $cur->{$key};
			}
			when ('ARRAY')
			{
				$key =~ /^\d+$/ and $key <= $#$cur or return undef;		# could also warn here, if not $check_existence
				$cur = $cur->[$key];
			}
			die("can't deref a scalar ($cur.$key)");
		}
	}

	return 1 if $check_existence;										# if we've gotten this far, it exists
	if (wantarray)
	{
		given (ref $cur)
		{
			return @$cur				when 'ARRAY';
			return keys %$cur			when 'HASH';
			return $cur					when '';
		}
	}
	return $cur;
}

func copy (@keys)
{
	my $dest = $_;
	local $_;
	$dest->{$_} = path() foreach @keys;
}

func clone ()
{
	my $dest = $_;
	local $_;
	$dest->{$_} = $j->{$_} foreach keys %$j;
}

func csv (@values)
{
	say join(',', map { s/"/\\"/g; qq{"$_"} } @values);
}

func tsv (@values)
{
	say join("\t", @values);
}

func count (@values)
{
	my $key = join(' // ', map { $_ // '<<undef>>' } @values);
	++$count_results{$key};
}
