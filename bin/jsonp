#! /usr/bin/env perl

use 5.014;
use autodie qw< :all >;
use warnings FATAL => 'all';
use experimental 'smartmatch';

use JSON;
use Method::Signatures;

$| = 1;


my $prog = shift or die("usage: $0 'perl program to process json lines' [file ...]");
our $j;
our %count_results;

my $processor = q{
	sub process
	{
		local $_ = {};
		no warnings 'exiting';
		##prog##;
		say to_json($_) if %$_;
	}
	1;
};
$processor =~ s/##prog##/$prog/;
eval $processor or die("$0: compile error: $@");

while ( <> )
{
	s/^.*?{/{/;
	unless ( eval { $j = from_json($_) } )
	{
		die("couldn't find valid json string in input") if eof();
		$_ .= <>;
		redo;
	}
	process();
}

if (%count_results)
{
	say "$_ : $count_results{$_}" foreach sort keys %count_results;
}


func p ($composite_key = $_)
{
	my $cur = $j;
	my @keys = split(/\./, $composite_key);
	while (@keys)
	{
		my $key = shift @keys;
		if ($key eq '*')
		{
			my @values;
			$composite_key = join('.', @keys);
			given (ref $cur)
			{
				@values = @$cur							when 'ARRAY';
				@values = values %$cur					when 'HASH';
				die("can't deref a scalar ($cur.*)");	# otherwise
			}
			my @subs;
			foreach (@values)
			{
				local $j = $_;
				push @subs, p($composite_key);
			}
			return wantarray ? @subs : \@subs;
		}

		given (ref $cur)
		{
			when ('HASH')
			{
				exists $cur->{$key} or return '';						# could also warn here
				$cur = $cur->{$key};
			}
			when ('ARRAY')
			{
				$key =~ /^\d+$/ and $key <= $#$cur or return '';		# could also warn here
				$cur = $cur->[$key];
			}
			die("can't deref a scalar ($cur.$key)");
		}
	}

	if (wantarray)
	{
		given (ref $cur)
		{
			return @$cur				when 'ARRAY';
			return keys %$cur			when 'HASH';
			return $cur					when '';
		}
	}
	return $cur;
}

func copy (@keys)
{
	my $dest = $_;
	local $_;
	$dest->{$_} = p() foreach @keys;
}

func clone ()
{
	my $dest = $_;
	local $_;
	$dest->{$_} = $j->{$_} foreach keys %$j;
}

func csv (@keys)
{
	say join(',', map { s/"/\\"/g; qq{"$_"} } map { p() } @keys);
}

func tsv (@keys)
{
	say join("\t", map { p() } @keys);
}

func count ($value)
{
	++$count_results{$value};
}
